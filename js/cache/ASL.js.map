{"version":3,"sources":["ASL.js"],"names":["rootObjectName","window","__GRN","ready","lazyMap","scrollCheckScheduled","resizeRecalculationScheduled","scrollHandlerRegistered","scheduleAnimationCheck","scheduleResizeRecalculation","checkLazyElements","recalculateLazyElements","ASL","requestAnimationFrame","threshold","item","windowHeight","innerHeight","scrollTop","pageYOffset","i","j","length","lazyProps","threshTop","threshBottom","scrollCallback","$element","splice","removeEventListener","bounds","getBoundingClientRect","parseInt","top","bottom","_scheduleAnimationCheck","_scheduleResizeRecalculation","registerScrollCallback","element","loadCallback","Element","rects","push","addEventListener","Error","registerScrollContainer","node","requiresRecalc","Node","TypeError","getLazyMap","modulePrepared"],"mappings":"CAAE,WACE,IAAIA,EAAiBC,OAAOC,MAE5BD,OAAOD,GAAgBG,MAAM,WAUK,IAatBC,EAOAC,EAOAC,EAOAC,EAKAC,EAWAC,EAWAC,EA2CAC,EAxGRV,OAAOD,GAAgBY,KAafR,KAOAC,GAAuB,EAOvBC,GAA+B,EAO/BC,GAA0B,EAK1BC,EAAyB,WACpBH,IACDA,GAAuB,EAEvBJ,OAAOY,sBAAsBH,KAOjCD,EAA8B,WACzBH,IACDA,GAA+B,EAE/BL,OAAOY,sBAAsBF,KAOjCD,EAAoB,WASpB,IAPA,IAIII,EACAC,EALAC,EAAef,OAAOgB,YACtBC,EAAYjB,OAAOkB,YACnBC,EAAI,EACJC,EAAIjB,EAAQkB,OAIRF,EAAIC,EAAGD,IAGXN,GADAC,EAAOX,EAAQgB,IACEN,UAGZC,EAAKQ,UAAUC,WAAcN,GAAaF,EAAgBA,EAAeF,IACzEC,EAAKQ,UAAUE,cAAiBP,EAAaF,EAAeF,IAEzDC,EAAKW,gBACLX,EAAKW,eAAeX,EAAKY,UAI7BvB,EAAQwB,OAAOR,EAAG,GAGlBA,IACAC,KAIHjB,EAAQkB,SACTrB,OAAO4B,oBAAoB,SAAUrB,GACrCP,OAAO4B,oBAAoB,SAAUpB,GACrCF,GAA0B,GAG9BF,GAAuB,GAMvBM,EAA0B,WAO1B,IALA,IAGImB,EAHAV,EAAI,EACJC,EAAIjB,EAAQkB,OACZJ,EAAYjB,OAAOkB,YAGfC,EAAIC,EAAGD,IACPhB,EAAQgB,GAAGO,UACXG,EAAS1B,EAAQgB,GAAGO,SAASI,wBAE7B3B,EAAQgB,GAAGG,UAAUC,UAAaQ,SAASF,EAAOG,KAAOf,EACzDd,EAAQgB,GAAGG,UAAUE,aAAgBO,SAASF,EAAOI,QAAUhB,IAE/Dd,EAAQwB,OAAOR,EAAG,GAElBA,IACAC,KAIRf,GAA+B,EAG/BI,MAWAyB,wBAAyB,WACrB3B,KAWJ4B,6BAA8B,WAC1B3B,KAeJ4B,uBAAwB,SAASC,EAASC,EAAczB,GACpD,GAAKwB,aAAmBE,SAAsC,mBAAnB,EAAgC,CAIvE,IAAIC,EAAQH,EAAQP,wBAKhBb,EAAYjB,OAAOkB,YAsBvB,OApBAf,EAAQsC,MACJf,SAAUW,EACVf,WACIC,UAAYQ,SAASS,EAAMR,KAAOf,EAClCO,aAAeO,SAASS,EAAMP,QAAUhB,GAE5CJ,UAAW,GAnLJ,GAoLPY,eAAgBa,IAGfhC,IACDN,OAAO0C,iBAAiB,SAAUnC,GAClCP,OAAO0C,iBAAiB,SAAUlC,GAElCF,GAA0B,GAI9BC,KAEO,EAGX,MAAM,IAAIoC,MAAM,8DAapBC,wBAAyB,SAASC,EAAMC,GACpC,GAAID,aAAgBE,KAQhB,OAPAF,EAAKH,iBAAiB,SAAU1C,OAAOD,GAAgBY,IAAIuB,yBAC3DW,EAAKH,iBAAiB,SAAU1C,OAAOD,GAAgBY,IAAIwB,8BAEvDW,GACAD,EAAKH,iBAAiB,SAAU1C,OAAOD,GAAgBY,IAAIwB,+BAGxD,EAGX,MAAM,IAAIa,UAAU,mDAUxBC,WAAY,WACR,OAAO9C,KAKnBH,OAAOD,GAAgBmD,eAAe,SAhQ7C","file":"ASL.js","sourcesContent":["!(function() {\n    var rootObjectName = window.__GRN;\n\n    window[rootObjectName].ready(function() {\n        /**\n         * @type {{\n         *   _scheduleAnimationCheck:      Function,\n         *   _scheduleResizeRecalculation: Function,\n         *   registerScrollCallback:       Function,\n         *   registerScrollContainer:      Function,\n         *   getLazyMap:                   Function,\n         * }} window[rootObjectName].ASL\n         */\n        window[rootObjectName].ASL = (function() {\n            /**\n             * The default threshold to load images off of the screen.\n             *\n             * @type {number} - The flotval percentage of the screen to allow callbacks to be run for the registered element\n             */\n            var defaultThreshold = .5;\n\n            /**\n             * The complete map of all registered and unloaded lazy items\n             *\n             * @type {Array}\n             */\n            var lazyMap = [];\n\n            /**\n             * State - True if a scroll check is scheduled for the next animation frame\n             *\n             * @type {boolean}\n             */\n            var scrollCheckScheduled = false;\n\n            /**\n             * State - True if a resize recalculation check is scheduled\n             *\n             * @type {boolean}\n             */\n            var resizeRecalculationScheduled = false;\n\n            /**\n             * State - True if the event handlers are currently attached\n             *\n             * @type {boolean}\n             */\n            var scrollHandlerRegistered = false;\n\n            /**\n             * Schedules an animation frame check for a scroll event to load in items\n             */\n            var scheduleAnimationCheck = function() {\n                if (!scrollCheckScheduled) {\n                    scrollCheckScheduled = true;\n\n                    window.requestAnimationFrame(checkLazyElements);\n                }\n            };\n\n            /**\n             * Schedules a resize recalculation check when the DOM size changes\n             */\n            var scheduleResizeRecalculation = function(){\n                if (!resizeRecalculationScheduled) {\n                    resizeRecalculationScheduled = true;\n\n                    window.requestAnimationFrame(recalculateLazyElements);\n                }\n            };\n\n            /**\n             * Checks all registered lazy elements against the current DOM bounds to see if they need to load in.  Calculations are based on the cached bounding boxes\n             */\n            var checkLazyElements = function() {\n                // Find the client bounds now\n                var windowHeight = window.innerHeight;\n                var scrollTop = window.pageYOffset;\n                var i = 0;\n                var j = lazyMap.length;\n                var threshold;\n                var item;\n\n                for (i; i < j; i++) {\n                    // Check if the element is in bounds\n                    item = lazyMap[i];\n                    threshold = item.threshold;\n\n                    if (\n                        (item.lazyProps.threshTop <= (scrollTop + (windowHeight + (windowHeight * threshold)))) &&\n                        (item.lazyProps.threshBottom >= (scrollTop - (windowHeight * threshold)))\n                    ) {\n                        if (item.scrollCallback) {\n                            item.scrollCallback(item.$element);\n                        }\n\n                        // Delete the element\n                        lazyMap.splice(i, 1);\n\n                        // We need to decrement the counters when the array is changed\n                        i--;\n                        j--;\n                    }\n                }\n\n                if (!lazyMap.length) {\n                    window.removeEventListener('scroll', scheduleAnimationCheck);\n                    window.removeEventListener('resize', scheduleResizeRecalculation);\n                    scrollHandlerRegistered = false;\n                }\n\n                scrollCheckScheduled = false;\n            };\n\n            /**\n             * Loops through all registered elements and recalculates the bounding boxes for each of them\n             */\n            var recalculateLazyElements = function() {\n                // So the user went and resized the window.  Recalculate all of the lazy element positions so they can be cached.  THIS IS BLOCKING!\n                var i = 0;\n                var j = lazyMap.length;\n                var scrollTop = window.pageYOffset;\n                var bounds;\n\n                for (i; i < j; i++) {\n                    if (lazyMap[i].$element) {\n                        bounds = lazyMap[i].$element.getBoundingClientRect();\n\n                        lazyMap[i].lazyProps.threshTop = (parseInt(bounds.top) + scrollTop);\n                        lazyMap[i].lazyProps.threshBottom = (parseInt(bounds.bottom) + scrollTop);\n                    } else {\n                        lazyMap.splice(i, 1);\n\n                        i--;\n                        j--;\n                    }\n                }\n\n                resizeRecalculationScheduled = false;\n\n                // Now Check the lazy elements, as they may now be on screen and need to be loaded\n                checkLazyElements();\n            };\n\n            return {\n                /**\n                 * Schedules an animation check to happen on the next paint\n                 *\n                 * @function\n                 *\n                 * @private\n                 */\n                _scheduleAnimationCheck: function() {\n                    scheduleAnimationCheck();\n                },\n\n                /**\n                 * Schedules an resize recalculation on the next paint\n                 *     DO NOT DO THIS UNLESS YOU ABSOLUTELY HAVE TO!\n                 *\n                 * @function\n                 *\n                 * @private\n                 */\n                _scheduleResizeRecalculation: function() {\n                    scheduleResizeRecalculation();\n                },\n\n                /**\n                 * Registers a new element that may be lazily loaded\n                 *\n                 * @function\n                 *\n                 * @param {Element}element - The DOMElement to use for the bounds of all calculations\n                 * @param {Function}loadCallback - The function callback used to run the load logic for the registered element\n                 *                                    Is passed the element registered as a parameter\n                 * @param {=float}threshold - The optional threshold to load in the element off the screen\n                 *\n                 * @throws Error - Whenever an invalid callback or invalid element is provided\n                 */\n                registerScrollCallback: function(element, loadCallback, threshold) {\n                    if ((element instanceof Element) && (typeof(loadCallback) === 'function')) {\n                        /**\n                         * @type {ClientRect}\n                         */\n                        var rects = element.getBoundingClientRect();\n\n                        /**\n                         * @type {number}\n                         */\n                        var scrollTop = window.pageYOffset;\n\n                        lazyMap.push({\n                            $element: element,\n                            lazyProps: {\n                                threshTop: (parseInt(rects.top) + scrollTop),\n                                threshBottom: (parseInt(rects.bottom) + scrollTop)\n                            },\n                            threshold: (threshold) ? threshold : defaultThreshold,\n                            scrollCallback: loadCallback\n                        });\n\n                        if (!scrollHandlerRegistered) {\n                            window.addEventListener('scroll', scheduleAnimationCheck);\n                            window.addEventListener('resize', scheduleResizeRecalculation);\n\n                            scrollHandlerRegistered = true;\n                        }\n\n                        // Schedule an animation frame check to instantly load elements already on the screen\n                        scheduleAnimationCheck();\n\n                        return true;\n                    }\n\n                    throw new Error('Must provide a valid element and callback for lazy loader');\n                },\n\n                /**\n                 * Binds a container to act as a new scroll binding for the abstract scroll loader\n                 *\n                 * @function\n                 *\n                 * @param node\n                 * @param requiresRecalc\n                 *\n                 * @returns {boolean}\n                 */\n                registerScrollContainer: function(node, requiresRecalc) {\n                    if (node instanceof Node) {\n                        node.addEventListener('scroll', window[rootObjectName].ASL._scheduleAnimationCheck);\n                        node.addEventListener('resize', window[rootObjectName].ASL._scheduleResizeRecalculation);\n\n                        if (requiresRecalc) {\n                            node.addEventListener('scroll', window[rootObjectName].ASL._scheduleResizeRecalculation);\n                        }\n\n                        return true;\n                    }\n\n                    throw new TypeError('Scroll Container Node must be instance of node');\n                },\n\n                /**\n                 * Gets the current registered lazy map\n                 *\n                 * @function\n                 *\n                 * @return Array|layMap - The map of all unloaded lazy elements\n                 */\n                getLazyMap: function() {\n                    return lazyMap;\n                }\n            }\n        }());\n\n        window[rootObjectName].modulePrepared('ASL');\n    });\n}());\n"]}